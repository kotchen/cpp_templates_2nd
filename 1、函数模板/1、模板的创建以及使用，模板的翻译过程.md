# Chapter 1、函数模板```Function Templates```

Come on~，首先模板就是**让编译器按照我们制定的规则来帮我们写代码**。听起来有点炫酷啊，下面就然我们来学习一下这个黑魔法吧~

这一章介绍了函数模板。函数模板就是被参数化了的函数，一个函数模板就代表了一个函数族。至于什么叫参数化，且听我慢慢道来。

## 1.1 只是因为在人群中多看了你一眼

我们可以像使用普通函数一样，使用函数模板。函数模板中有一些元素没有确定，等着我们参数化呢，为了解释什么是参数化，请看下面一个简单的例子。

### 1.1.1 ”我要说的事，你们千万别害怕！“——定义一个函数模板

以下就是一个函数模板，它返回两个值之间较大的那个：

```c++
// basics/max1.hpp
template<typename T>
T max(T a, T b)
{
    // 左边的值和右边的值比较，返回较大的那个，如果相等，就返回右边的值。
	return a > b ? a : b;
}
```

这个模板定义确定了一个函数族，我们可以向这个函数传入两个类型一样的值，它可以返回两个值之间较大的那个，如果两个值相同，那么就会返回右边的参数。

这里**两个值相等时返回左边的值还是右边的值**，这里有一些解释：[奥里给GOGOGOGO!!!!!!](https://www.zhihu.com/question/266917342)

这些参数的类型被保留为模板参数```T```。我们用```<>```括住这些模板参数，如果有多个模板参数就用逗号隔开。用关键字```typename```引入一个类型参数。当然我们也可以用别的关键字，但是```typename```是最常见。

在这个例子中，我们用的是```T```作为类型参数，我们可以用任何标识符作为一个类型参数，但是使用```T```其实是一个惯例。类型参数可以表示任何一个类型，当使用者要使用的时候被确定。**你可使用基本类型或者一个类等，只要它提供了你在模板中使用的操作。**比如上面这个比大小，你传入的值的类型必须支持这个比大小的操作。当然，这里还有一个不明显的限制就是，这里返回了一个```T```类型的值，这意味着```T```能够被复制。

因为历史原因，```class```也是可以用作类型参数引入。但是这可能产生一些误会，我们只能传入一个```class```，但是其实所有类型都是可以传入的。

有人就会问```struct```行不行，很遗憾，它不行。：）

### 1.1.2 “ 让我康康! ”——使用函数模板

下面的代码展示了如何使用函数模板

```c++
// basics/max1.cpp
#include <iostream>
#include <string>
#include "max1.h"


int main()
{
	int i = 42;
	std::cout << "max(7, i):   " << ::max(7, i) << '\n';

	double f1 = 3.4;
	double f2 = -6.7;
	std::cout << "max(f1, f2):   " << ::max(f1, f2) << '\n';

	std::string s1 = "mathematics";
	std::string s2 = "math";
	std::cout << "max(s1, s2):   " << ::max(s1, s2) << '\n';
}

// 在这段程序中，max()被调用了3次，每次二者中的最大值都被算出了，输出结果如下：
// max(7, i):   42
// max(f1, f2):   3.4
// max(s1, s2):   mathematics
```

注意，这里每次使用都用```::```限定，这是为了确保我们的函数模板是在全局的```namespace```中找到的，在标准库中有一个```std::max()```，这里是确保如果在```using namespace std;```的情况下，还能正常调用我们自己的函数模板。

在上一个例子中，我们调用了3次模板，编译器就帮我们写了如下代码

```c++
int max(int a, int b)
{
	
	return a > b ? a : b;
}
double max(double a, double b)
{
	
	return a > b ? a : b;
}
std::string max(std::string a, std::string b)
{
	
	return a > b ? a : b;
}
```

**用具体的类型替换类型参数的过程叫做实例化，它产生了一个模板的实例。**

### 1.1.3 “我们是警察 我们不会怕”——模板的翻译阶段

如果试图实例化一个不支持模板中操作的的类型，那么你将收到一个”compile-time error"，举个例子：

```c++
std::complex<float> c1, c2;
::max(c1, c2); // error!
```

总所周知，复数是不能比大小的，所以，这里就会报错了。

下面就让我们康康模板“编译”的两个阶段```Two-Phase Translation```：

- 实例化阶段之前，就叫定义阶段吧，先忽略模板参数，检查一遍代码
  - 语法检查，比如有没有少分号```;```。
  - 找到不依赖模板参数的未知名称（类型名称，函数名称）。
  - 检查不依赖模板参数的静态断言。
- 实例化阶段：模板代码会被再检查一遍，确保这些代码是有效的。所有依赖模板参数的部分会被检查两次。

举个例子：

```c++
template<typename T>
void foo(T t)
{
	undeclared();   // 如果这个函数是未知的，那么在第一阶段就会编译失败
	undeclared(t);  // 如果函数undeclared(T)是未知的，那么在第二阶段编译失败
	static_assert(sizeof(int) > 10, // 只要sizeof(int) <= 10 就编译失败
		         "int too small");
	static_assert(sizeof(T) > 10,   // 实例化的时候，如果sizeof(T) <= 就编译失败
				 "T too small");
}
```

名字被检查俩次有有一个官方称呼```two-phase lookup```，这个以后再说。

注意，有些编译器在第一阶段并不会执行全面检查，所以在你实例化之前可能不会出现任何错误信息。：）

**编译与链接**

在实际处理模板的时候，```Two-Phase Translation```会导致一个重要的问题：当一个函数模板要被实例化的时候，编译器要去看看（某些时候）这个模板的**定义**。当函数的**声明**已经足以编译时使用时，这就破坏了模板函数与普通函数在编译与链接时候的区别。这个问题我们在之后讨论，现在，我们就关注最简单的方式：在一个头文件内实现每一个模板。	

