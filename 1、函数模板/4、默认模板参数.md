# Chapter 1、 函数模板```Function Templates```

## 1.4 默认模板参数

你可以为模板参数设置默认值，这些值叫做默认模板参数，并且可以被任何模板使用。他们甚至可以参考以前的模板参数。

举个例子，如果你想把**定义返回值的类型**以及**传入多个模板参数**这俩操作结合起来，你就可以使用一个通用为返回值类型引入一个模板参数```RT```作为默认值，它的值就是前面模板参数的通用类型```common type```。

如果要这样操作的话，我们又有好几种方式来实现它

1、我们可以使用```?:```。这个很直接，但是因为我们使用的是```?:```，在调用参数```a,b```声明之前，我们只能使用它们的类型。

```c++
template<typename T1, typename T2, 
		 typename RT = std::decay_t<decltype(true ? T1() : T2())>>
RT max(T1 a, T2 b)
{
	return a > b ? a : b;
}
```

注意，这里使用```std::decay_t<>```来确保不会返回引用类型。（```since C++14```）

还有一件事，注意这里的实现方法```typename RT = std::decay_t<decltype(true ? T1() : T2())>```意味着传入的```T1, T2```类型是有默认的构造函数的。

另一种解决方案是使用```std::declval```，然而这样会让声明变得更加复杂。这个我们以后再说。

2、使用```std::common_type<>```为返回值类型指定默认值。

```c++
template<typename T1, typename T2, 
		 typename RT = std::common_type_t<T1,T2>>
RT max(T1 a, T2 b)
{
	return a > b ? a : b;
}
```

再一次注意，```std::common_type```是```decay```的，为了防止返回引用类型。

现在，在任何情况下，作为一个调用者，你可以使用默认值作为返回值的类型。

```auto a = ::max(4, 7.2);```

或者在其他参数全部显示声明之后，再指定返回值的类型。

```auto b = ::max<double, int, long double> (7.2, 4);```

这样写的话，在写返回值之前，我们又得把所有调用参数的类型全写出来。

我们需要将返回类型作为第一个模板参数，然鹅依然有能力根据其他参数类型将它推导出来。原则上，即使后面跟随没有默认参数的参数，也可以为引导函数模板参数设置默认参数：

```c++
template<typename RT = long, typename T1, typename T2>
RT max(T1 a, T2 b)
{
	return a > b ? a : b;
}
```

根据这个定义，我们可以这样调用：

```c++
int i;
long l;
...
max(i, l);           // 返回long
max<int> (4, 42);    // 返回int
```

然而，这种方法只有在模板有一个“天然”的默认模板参数的时候，比如这里的```long```，才有意义。现在，我们需要**模板参数**的**默认参数**是**依赖于之前传入的参数**的。原则上，这是可行的，这个我们以后再说，但是这个东东依赖于```type trait```，这样让这个定义更加复杂了。

综上所述，让编译器自己推导返回值才是明智之举。所以，在```1.3.2```中提到的方案才是最优的方案。

```auto```暂时的神：）