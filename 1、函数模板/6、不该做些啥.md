# Chapter 1、 函数模板```Function Templates```

## 1.6 我们不应该？

即使是最简单的模板也可能导致一些深层次的问题，现在，我们就在这里简单讨论3个比较普遍的问题。

### 1.6.1 传值还是传引用？

你可能会想，为什么我们一般在声明函数的时候是传值而不是传引用。一般来说，参数的类型是一些基础类型，或者是```std::string_view```，就传值，否则传引用是一种更好的方式，这样省去了复制的开销。

然鹅，基于一下的几个理由，传值是一种更好的方式。

- 语法简单
- 编译器更好优化
- 移动语义使得拷贝变得廉价（开销更小）
- 有时这里根本没有拷贝或者移动

除此之外，对于模板，

- 一个模板可能被用于简单的类型，也有可能用于复杂的类型。所以，对复杂类型有益的方法，对简单类型可能会产生反作用。
- 作为函数的调用者，你依然需要考虑是传值还是传引用，使用```std::ref() , std::cref()```(在7.3中说明)
- 虽然传递一个字符串或者一个数组经常产生一些问题，但是将传递它们的引用被认为会造成更大的问题。

这些会在第7章中讨论。现在，这本书中，我们一般是传值，除非一些功能只能用引用实现。

### 1.6.2 为什么不使用```inline```

一般来说，函数模板没有必要声明为```inline```。不像普通的非```inline```函数，我们可以在头文件中定义非```inline```的函数模板，并且用在多个我们想要的```.cpp```文件。

一个例外就是，对于一些特定类型的全特化，这样导致了最终的代码不再泛型（就是所有的模板参数都被写死了）。在9.2节中具体说明。

从严格的语言定义来看，```inline```仅仅意味着定义的一个函数可以在一个程序中多次出现。然鹅，它也暗示编译器，调用的时候要，函数要被拓展为```inline```：按这样做，可以产生一些更高效的代码对于某些具体的情况，但是它可能对其他情况来说是一种更低效的做法。如今，编译器已经足够牛逼了，即使没有```inline```标记，它也可以决定是否```inline```。

### 1.6.3 为什么不使用```constexpr```

从```C++11```开始，你可以使用```constexpr```来提供一种**在编译期**，使用代码来**计算某些值**的能力。对于许多模板来所，这是有意义的。（或者说产生编译器值）

举个例子，为了能够在编译期使用这个求最大值的模板，我们可以这样声明：

```c++
template<typename T1, typename T2>
constexpr auto max(T1 a, T2 b)
{
	return a > b ? a : b;
}
```

这样，我们就可以在涉及编译器内容的时候使用这个最大值函数模板，比如，当声明一个数组的大小的时候：

```int a[::max(sizeof(char), 1000u)];```

或者是一个```std::array<>```的长度的时候:

```std::array<std::string, ::max(sizeof(char), 1000u)> arr;```

注意，这里我们将1000作为```unsigned int```传入是为了避免产生一个将```unsiged int ```与```int```进行比较的警告。

在8.2节中我们将会讨论使用```constexpr```的其他例子，然鹅，为了聚焦于基础知识，我们在讨论其他模板特性的时候就先跳过```constexpr```。

